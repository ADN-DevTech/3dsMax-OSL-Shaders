// Simple Dot-Matrix printing shader
// By Tristan LaPalme
// Modified: 2018-03-22
// Copyright 2018 Autodesk Inc, All rights reserved. This file is licensed under Apache 2.0 license
//    https://github.com/ADN-DevTech/3dsMax-OSL-Shaders/blob/master/LICENSE.txt

shader DotMatrix
[[ string help="Dot Matrix Font String Shader" ]]
(
	vector UVW     = vector(u, v, 0),
	float  Scale   = 1.0,
	string Text    = "OSL",
	float  Padding = 0.05,
	float  Inset   = 0.1,
	color  On      = color(1.0,0,0),
	color  Off     = color(0.2,0,0),
	color  Back    = color(0,0,0),
	
	output color Out = 0)
{
	float txU = UVW[0] / Scale;
	float txV = UVW[1] / Scale;
	
	int mSize = 35;
	int m[910] = {
					//a
				    0,1,1,1,0,
					1,0,0,0,1,
					1,0,0,0,1,
					1,1,1,1,1,
					1,0,0,0,1,
					1,0,0,0,1,
					1,0,0,0,1,
						
					//b
				    1,1,1,1,0,
					1,0,0,0,1,
					1,0,0,0,1,
					1,1,1,1,0,
					1,0,0,0,1,
					1,0,0,0,1,
					1,1,1,1,0,
				
					//c
				    0,1,1,1,0,
					1,0,0,0,1,
					1,0,0,0,0,
					1,0,0,0,0,
					1,0,0,0,0,
					1,0,0,0,1,
					0,1,1,1,0,
				
					//d
				    1,1,1,1,0,
					1,0,0,0,1,
					1,0,0,0,1,
					1,0,0,0,1,
					1,0,0,0,1,
					1,0,0,0,1,
					1,1,1,1,0,
				
					//e
				    1,1,1,1,1,
					1,0,0,0,0,
					1,0,0,0,0,
					1,1,1,1,1,
					1,0,0,0,0,
					1,0,0,0,0,
					1,1,1,1,1,
					
					//f
				    1,1,1,1,1,
					1,0,0,0,0,
					1,0,0,0,0,
					1,1,1,1,1,
					1,0,0,0,0,
					1,0,0,0,0,
					1,0,0,0,0,
					
					//g
				    0,1,1,1,0,
					1,0,0,0,1,
					1,0,0,0,0,
					1,0,0,0,0,
					1,0,1,1,1,
					1,0,0,0,1,
					0,1,1,1,1,
					
					//h
				    1,0,0,0,1,
					1,0,0,0,1,
					1,0,0,0,1,
					1,1,1,1,1,
					1,0,0,0,1,
					1,0,0,0,1,
					1,0,0,0,1,
					
					//i
				    0,1,1,1,0,
					0,0,1,0,0,
					0,0,1,0,0,
					0,0,1,0,0,
					0,0,1,0,0,
					0,0,1,0,0,
					0,1,1,1,0,
					
					//j
				    0,0,0,0,1,
					0,0,0,0,1,
					0,0,0,0,1,
					0,0,0,0,1,
					0,0,0,0,1,
					1,0,0,0,1,
					0,1,1,1,0,
					
					//k
				    1,0,0,0,1,
					1,0,0,1,0,
					1,0,1,0,0,
					1,1,0,0,0,
					1,0,1,0,0,
					1,0,0,1,0,
					1,0,0,0,1,
					
					//l
				    1,0,0,0,0,
					1,0,0,0,0,
					1,0,0,0,0,
					1,0,0,0,0,
					1,0,0,0,0,
					1,0,0,0,0,
					1,1,1,1,1,
					
					//m
				    1,0,0,0,1,
					1,1,0,1,1,
					1,0,1,0,1,
					1,0,1,0,1,
					1,0,0,0,1,
					1,0,0,0,1,
					1,0,0,0,1,
					
					//n
				    1,0,0,0,1,
					1,0,0,0,1,
					1,1,0,0,1,
					1,0,1,0,1,
					1,0,0,1,1,
					1,0,0,0,1,
					1,0,0,0,1,
					
					//o
				    0,1,1,1,0,
					1,0,0,0,1,
					1,0,0,0,1,
					1,0,0,0,1,
					1,0,0,0,1,
					1,0,0,0,1,
					0,1,1,1,0,
					
					//p
				    1,1,1,1,0,
					1,0,0,0,1,
					1,0,0,0,1,
					1,1,1,1,0,
					1,0,0,0,0,
					1,0,0,0,0,
					1,0,0,0,0,
					
					//q
				    0,1,1,1,0,
					1,0,0,0,1,
					1,0,0,0,1,
					1,0,0,0,1,
					1,0,1,0,1,
					1,0,0,1,0,
					0,1,1,0,1,
					
					//r
				    1,1,1,1,0,
					1,0,0,0,1,
					1,0,0,0,1,
					1,1,1,1,0,
					1,0,1,0,0,
					1,0,0,1,0,
					1,0,0,0,1,
					
					//s
				    0,1,1,1,0,
					1,0,0,0,1,
					1,0,0,0,0,
					0,1,1,1,0,
					0,0,0,0,1,
					1,0,0,0,1,
					0,1,1,1,0,
					
					//t
				    1,1,1,1,1,
					0,0,1,0,0,
					0,0,1,0,0,
					0,0,1,0,0,
					0,0,1,0,0,
					0,0,1,0,0,
					0,0,1,0,0,
					
					//u
				    1,0,0,0,1,
					1,0,0,0,1,
					1,0,0,0,1,
					1,0,0,0,1,
					1,0,0,0,1,
					1,0,0,0,1,
					0,1,1,1,0,
					
					//v
				    1,0,0,0,1,
					1,0,0,0,1,
					1,0,0,0,1,
					0,1,0,1,0,
					0,1,0,1,0,
					0,0,1,0,0,
					0,0,1,0,0,
					
					//w
				    1,0,0,0,1,
					1,0,0,0,1,
					1,0,0,0,1,
					1,0,1,0,1,
					1,0,1,0,1,
					1,1,0,1,1,
					1,0,0,0,1,
					
					//x
				    1,0,0,0,1,
					1,0,0,0,1,
					0,1,0,1,0,
					0,0,1,0,0,
					0,1,0,1,0,
					1,0,0,0,0,
					1,0,0,0,1,
					
					//y
				    1,0,0,0,1,
					1,0,0,0,1,
					0,1,0,1,0,
					0,0,1,0,0,
					0,0,1,0,0,
					0,0,1,0,0,
					0,0,1,0,0,
					
					//z
				    1,1,1,1,1,
					0,0,0,0,1,
					0,0,0,1,0,
					0,0,1,0,0,
					0,1,0,0,0,
					1,0,0,0,0,
					1,1,1,1,1
				};

	int n[350] = {
					//0
				    0,1,1,1,0,
					1,0,0,0,1,
					1,0,0,1,1,
					1,0,1,0,1,
					1,1,0,0,1,
					1,0,0,0,1,
					0,1,1,1,0,
					
					//1
				    0,0,1,0,0,
					0,1,1,0,0,
					0,0,1,0,0,
					0,0,1,0,0,
					0,0,1,0,0,
					0,0,1,0,0,
					0,1,1,1,0,
					
					//2
				    0,1,1,1,0,
					1,0,0,0,1,
					1,0,0,0,1,
					0,0,1,1,0,
					0,1,0,0,0,
					1,0,0,0,0,
					1,1,1,1,1,
					
					//3
				    0,1,1,1,0,
					1,0,0,0,1,
					0,0,0,0,1,
					0,1,1,1,0,
					0,0,0,0,1,
					1,0,0,0,1,
					0,1,1,1,0,
					
					//4
				    0,0,0,1,0,
					0,0,1,1,0,
					0,1,0,1,0,
					1,0,0,1,0,
					1,1,1,1,1,
					0,0,0,1,0,
					0,0,0,1,0,
					
					//5
				    1,1,1,1,1,
					1,0,0,0,0,
					1,1,1,1,0,
					0,0,0,0,1,
					0,0,0,0,1,
					1,0,0,0,1,
					0,1,1,1,0,
					
					//6
				    0,0,1,1,0,
					0,1,0,0,0,
					1,0,0,0,0,
					1,1,1,1,0,
					1,0,0,0,1,
					1,0,0,0,1,
					0,1,1,1,0,
					
					//7
				    1,1,1,1,1,
					0,0,0,0,1,
					0,0,0,1,0,
					0,0,1,0,0,
					0,1,0,0,0,
					0,1,0,0,0,
					0,1,0,0,0,
					
					//8
				    0,1,1,1,0,
					1,0,0,0,1,
					1,0,0,0,1,
					0,1,1,1,0,
					1,0,0,0,1,
					1,0,0,0,1,
					0,1,1,1,0,
					
					//9
				    0,1,1,1,0,
					1,0,0,0,1,
					1,0,0,0,1,
					0,1,1,1,1,
					0,0,0,0,1,
					0,0,0,1,0,
					0,1,1,0,0
				};
	Out = Back;
				
	if(txU > Padding && txU <= 1.0 - Padding)
	{
		float paddedU = ((txU-Padding) / (1.0-2.0*Padding)) ;	
	
		int l = strlen(Text);
		int cIndex = (int)floor(paddedU*l);
		int cAscii = getchar(Text, cIndex);
		
		int mBase = -1;
		int nBase = -1;
		
		if(cAscii > 64 && cAscii < 91)
		{
			int mIndex = cAscii-65;
			mBase = mIndex * 35;
		}		
		else if(cAscii > 96 && cAscii < 123)
		{
			int mIndex = cAscii-97;
			mBase = mIndex * 35;
		}
		else if(cAscii > 47 && cAscii < 58)
		{
			int nIndex = cAscii-48;
			nBase = nIndex * 35;
		}
		
		if(mBase != -1 || nBase != -1)
		{
			float matrixSize = 7.0;
			float inc = 1.0/matrixSize;

			float floatL = (float)l;
			float paddedV = 1.0 - ( txV * floatL - floor(0.5*floatL) );
			
			// draw char
			float charU = fmod(paddedU*(float)l, 1.0); 
			
			float uu = charU*matrixSize;
			float vv = paddedV*matrixSize;

			if(paddedV >= 0.0 && paddedV <= 1.0)
			{
				int intU = (int)floor(uu);
				int intV = (int)floor(vv);
				
				if(intU > 0 && intU < 6)
				{
					int lookup = 0;
					int index = (intV * 5) + intU - 1;
					if(mBase != -1)
					{
						lookup = m[index + mBase];
					} 
					else
					{
						lookup = n[index+nBase];
					}

					float uPos = uu - (float)intU;
					float vPos = vv - (float)intV;
					if( uPos > Inset && uPos < 1.0-Inset && vPos > Inset && vPos < 1.0-Inset )
					{
						if (lookup == 1)
						{
							Out = On;
						}
						else
						{
							Out = Off;
						}
					}
				}			
			}
		}
	}	
}
